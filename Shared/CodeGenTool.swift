//
//  CodeGenTool.swift
//  assetgen
//
//  Created by Tadeas Kriz on 05/01/15.
//  Copyright (c) 2015 Brightify. All rights reserved.
//

import Foundation

class CodeGenTool {
    
    var inputURL: NSURL
    var classPrefix: String
    var skipClassDeclaration: Bool
    var toolName: String
    
    var className: String?
    var contents: [String] = []
    
    required init(inputURL: NSURL, classPrefix: String, toolName: String) {
        self.inputURL = inputURL
        self.classPrefix = classPrefix
        self.toolName = toolName
        self.skipClassDeclaration = false
    }
    
    func startWithCompletionHandler(completionClosure: () -> ()) {
        fatalError("Unimplemented abstract method: startWithCompletionHandler")
    }
    
    func writeOutputFiles() {
        assert(self.className != nil, "Class name isn't set")
        
        let className = self.className!
        let fileManager = NSFileManager()
        let currentDirectory = fileManager.currentDirectoryPath
        let classURL: NSURL! = NSURL(fileURLWithPath: currentDirectory.stringByAppendingPathComponent(className).stringByAppendingPathExtension("swift")!)
        
        self.contents.sort({ (obj1, obj2) -> Bool in
            return obj1.compare(obj2) == NSComparisonResult.OrderedAscending
        })

        var output = "//\n// This file is generated from \(inputURL.lastPathComponent!) by \(toolName).\n// Please do not edit this file.\n//\n\nimport UIKit\n\n\n"
        let methods = contents.reduce("") { (accumulator, value) -> String in
            accumulator + value
        }
        if(skipClassDeclaration) {
            output += methods
        } else {
            output += "class \(className) {\n\n\(methods)}\n"
        }
        
        if(output != String(contentsOfURL: classURL, encoding: NSUTF8StringEncoding, error: nil)) {
            output.writeToURL(classURL, atomically: true, encoding: NSUTF8StringEncoding, error: nil)
        }
        println("Wrote \(className) to \(currentDirectory)")
    }
    
    func methodNameForKey(var key: String) -> String {
        // If the string is already all caps, it's an abbrevation. Lowercase the whole thing.
        // Otherwise, camelcase it by lowercasing the first character.
        if (key == key.uppercaseString) {
            key = key.lowercaseString
        } else {
            let range = Range<String.Index>(start: key.startIndex, end: advance(key.startIndex, 1))
            key = key.stringByReplacingCharactersInRange(range, withString: key.substringWithRange(range).lowercaseString)
        }
        
        
        key = key.stringByReplacingOccurrencesOfString("" , withString: "", options: NSStringCompareOptions.allZeros, range: wholeStringRange(key))
        key = key.stringByReplacingOccurrencesOfString("~" , withString: "", options: NSStringCompareOptions.allZeros, range: wholeStringRange(key))
        key = key.stringByReplacingOccurrencesOfString("@" , withString: "", options: NSStringCompareOptions.allZeros, range: wholeStringRange(key))
        key = key.stringByReplacingOccurrencesOfString("-" , withString: "_", options: NSStringCompareOptions.allZeros, range: wholeStringRange(key))
        return key        
    }
    
    class func start() {
        var searchURLOrNil: NSURL?
        var classPrefix = ""
        var inputURLs: [NSURL?] = []
        let programName = Process.arguments[0].lastPathComponent
        let argumentCount = Process.arguments.count
        var lastParsedIndex = 0
        if(argumentCount > 1) {
            for var i = 1; i < argumentCount - 1; i++ {
                let argument = Process.arguments[i]
                
                if(argument.hasPrefix("-")) {
                    switch(argument) {
                    case "-h":
                        printHelp()
                        return
                    case "-o":
                        let nextIndex = ++i
                        let outputPath = Process.arguments[nextIndex].stringByExpandingTildeInPath
                        NSFileManager.defaultManager().changeCurrentDirectoryPath(outputPath)
                        lastParsedIndex = i
                    case "-f":
                        let nextIndex = ++i
                        let searchPath = Process.arguments[nextIndex].stringByExpandingTildeInPath
                        searchURLOrNil = NSURL.fileURLWithPath(searchPath)
                        lastParsedIndex = i
                    case "-p":
                        let nextIndex = ++i
                        classPrefix = Process.arguments[nextIndex]
                        lastParsedIndex = i
                    default:
                        break
                    }
                }
            }
            
        } else {
            printHelp()
            return
        }
        if(lastParsedIndex < argumentCount - 1) {
            for i in (lastParsedIndex + 1)...(argumentCount - 1) {
                let inputPath = Process.arguments[i].stringByExpandingTildeInPath
                let inputURL = NSURL.fileURLWithPath(inputPath)
                inputURLs.append(inputURL)
            }
        }
        
        if let searchURL = searchURLOrNil {
            let enumeratorOrNil = NSFileManager.defaultManager().enumeratorAtURL(searchURL, includingPropertiesForKeys: [String(NSURLNameKey)], options: NSDirectoryEnumerationOptions.allZeros, errorHandler: nil)
            if let enumerator = enumeratorOrNil {
                while let url: NSURL = enumerator.nextObject() as? NSURL {
                    if url.pathExtension == inputFileExtension() {
                        inputURLs.append(url)
                    }
                }
            }
            
        }
        
        let group = dispatch_group_create()
        
        for urlOrNil in inputURLs {
            if let url = urlOrNil {
                dispatch_group_enter(group)
                
                let target = self.init(inputURL: url, classPrefix: classPrefix, toolName: programName)
                target.startWithCompletionHandler({
                    dispatch_group_leave(group)
                })
            }
        }

        dispatch_group_wait(group, DISPATCH_TIME_FOREVER)
    }
    
    class func inputFileExtension() -> String {
        fatalError("Unimplemented abstract method: inputFileExtension")
    }
    
    private class func printHelp() {
        let programName = Process.arguments[0].lastPathComponent
        
        println("Usage: \(programName) [-o <path>] [-f <path>] [-p <prefix>] [<paths>]")
        println("       \(programName) -h")
        println()
        println("Options:")
        println("    -o <path>   Output files at <path>.")
        println("    -f <path>   Search for *.\(inputFileExtension()) folders starting from <path>.")
        println("    -p <prefix> Use <prefix> as the class prefix in the generated code.")
        println("    -h          Print this help and exit.")
        println("    <paths>     Input files; this and/or -f are required.")
    }
    
    
}